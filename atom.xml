<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>moefh.github.io</title>
  
  <subtitle>The Magic Smoke Has Left the Building</subtitle>
  <link href="http://moefh.github.io/atom.xml" rel="self"/>
  
  <link href="http://moefh.github.io/"/>
  <updated>2021-05-15T16:00:27.155Z</updated>
  <id>http://moefh.github.io/</id>
  
  <author>
    <name>MoeFH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Using Wii I2C Controllers on the ESP32</title>
    <link href="http://moefh.github.io/2021/05/15/Using-Wii-I2C-Controllers-on-the-ESP32/"/>
    <id>http://moefh.github.io/2021/05/15/Using-Wii-I2C-Controllers-on-the-ESP32/</id>
    <published>2021-05-15T15:38:48.000Z</published>
    <updated>2021-05-15T16:00:27.155Z</updated>
    
    <content type="html"><![CDATA[<p>I wrote a very simple library to make the ESP32 talk via I2C to Wiicontrollers like the Wii Nunchuk and the Wii Classic Controller.</p><p>There are a few libraries around that do this for the Arduino usingthe <a href="https://www.arduino.cc/en/reference/wire"><code>Wire</code> library</a>, butfor some reason that doesn’t work consistently with the ESP32 and theWii controllers.  So I wrote the I2C communication using the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/i2c.html">ESP-IDFAPI</a>,and it works really well, except that for some reason I wasn’t able tomake it work at 400KHz (which is supposedly what the Wii controllersaccept), only at 100KHz.  That’s a little disappointing, but goodenough for my purposes, which is using the controllers in the ESP32port of Loser Corps.</p><p>While playing with it, I wrote a little test program to display thestate of the connected controller on a small OLED screen (SSD1306),which is controlled using the <a href="https://github.com/adafruit/Adafruit_SSD1306">Adafruit SSD1306library</a> also via I2C,but using the <code>Wire</code> library:</p><p><img src="/2021/05/15/Using-Wii-I2C-Controllers-on-the-ESP32/photo.jpg" alt="Testing the Wii Classic Controler"></p><p>When using the Wii Classic Controller, the screen shows two trianglesthat point on the direction where you move the sticks, growing in sizeas you move the stick farther along.  Pressing each button lights acorresponding character on the screen, and pulling the analog triggersincreases the size of two bars that appear on the left side.</p><p>When using the Wii Nunchuk, the screen shows a single triangle withthe status of the nunchuk stick and three bars to the left that showthe status of the X, Y and Z accelerometer readings.  Pressing C or Zdisplays the corresponding letter on the screen.</p><p>I wrote this small test program mostly for fun, but it tests somethingimportant: that my library, which uses I2C via ESP-IDF, can coexistwith <code>Wire</code> library.  When using them together, you just have to becareful not to use the same ESP32 I2C port with the two libraries atthe same time.  In this program, my library uses I2C port 0 and the<code>Wire</code> library uses I2C port 1 (by using the <code>Wire1</code> object).</p><p>The source code for the library is here:<a href="https://github.com/moefh/esp32-wii-nunchuk">https://github.com/moefh/esp32-wii-nunchuk</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I wrote a very simple library to make the ESP32 talk via I2C to Wii
controllers like the Wii Nunchuk and the Wii Classic Controller.&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="i2c" scheme="http://moefh.github.io/tags/i2c/"/>
    
    <category term="wii" scheme="http://moefh.github.io/tags/wii/"/>
    
    <category term="nunchuk" scheme="http://moefh.github.io/tags/nunchuk/"/>
    
  </entry>
  
  <entry>
    <title>Porting Loser Corps to the ESP32 - Part 5</title>
    <link href="http://moefh.github.io/2021/04/17/Porting-Loser-Corps-to-the-ESP32-Part-5/"/>
    <id>http://moefh.github.io/2021/04/17/Porting-Loser-Corps-to-the-ESP32-Part-5/</id>
    <published>2021-04-17T17:04:59.000Z</published>
    <updated>2021-04-17T17:28:25.355Z</updated>
    
    <content type="html"><![CDATA[<p>More progress in porting Loser Corps to the ESP32 (<a href="/2021/02/28/Porting-Loser-Corps-to-the-ESP32/" title="here&#39;s part 1">here&#39;s part 1</a> of the saga).</p><p>This is just a quick update: I have added shooting to the game.  Youshoot by pressing ② in the Wiimote (or <code>D</code> in the Arduino joystick).There can be at most 14 shots active at once, and they do nothing butfly in a straight line until they hit a wall or the edge of the map.</p><p><img src="/2021/04/17/Porting-Loser-Corps-to-the-ESP32-Part-5/shot.jpg" alt="Scheenshot of projectile (the camera doesn&#39;t like moving objects, in reality it&#39;s less blurry than shown here)"></p><p>I also ported the game to use the ESP-IDF framework (as opposed to theArduino framework, which originally used).  I’m trying to see if I candecrease the memory used by the WiFi system so the game can use full320x240 resolution while in networked mode, and the EDP-IDF frameworkhas lots of configuration options.  I haven’t made much progress withit yet: I was just recently able to make the game run at full speed,after finding that I have to set not ony the processor clock to 240MHzbut also the flash SPI clock to 80MHz (apparently the flash speed is abottleneck, which is not surprising since we copy images directly fromflash to the framebuffer).</p><p>As usual, the source is on<a href="https://github.com/moefh/esp32-loser">Github</a> (I realize I haven’twritten this beforem, so from now on I’ll start adding this link toevery post).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;More progress in porting Loser Corps to the ESP32 (&lt;a href=&quot;/2021/02/28/Porting-Loser-Corps-to-the-ESP32/&quot; title=&quot;here&amp;#39;s part 1&quot;&gt;here</summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
    <category term="loser-corps" scheme="http://moefh.github.io/tags/loser-corps/"/>
    
  </entry>
  
  <entry>
    <title>Porting Loser Corps to the ESP32 - Part 4</title>
    <link href="http://moefh.github.io/2021/04/04/Porting-Loser-Corps-to-the-ESP32-Part-4/"/>
    <id>http://moefh.github.io/2021/04/04/Porting-Loser-Corps-to-the-ESP32-Part-4/</id>
    <published>2021-04-04T03:10:58.000Z</published>
    <updated>2021-04-04T04:07:20.041Z</updated>
    
    <content type="html"><![CDATA[<p>More progress in porting Loser Corps to the ESP32 (<a href="/2021/02/28/Porting-Loser-Corps-to-the-ESP32/" title="here&#39;s part 1">here&#39;s part 1</a> of the saga).</p><p>Working on the game network code, I was able to make two players (eachrunning their own game a separate ESP32) see each other’s characters:</p><p><img src="/2021/04/04/Porting-Loser-Corps-to-the-ESP32-Part-4/loser-net1.jpg" alt="First player (using the Arduino Joystick)"></p><p><img src="/2021/04/04/Porting-Loser-Corps-to-the-ESP32-Part-4/loser-net2.jpg" alt="Second player (using the Wiimote)."></p><p>They’re using<a href="https://www.espressif.com/en/products/software/esp-now/overview">ESP-NOW</a>(a protocol made by Espressif, the makers of ESP32) to communicate.Currently code is very simple, it’s really just a proof-of-concept.Each ESP32 keeps broadcasting messages containing its character’sposition and frame.  When it receives a message, it puts a secondcharacter at the received location with the received frame torepresent the remote player.</p><p>The network part was much easier than expected, I got it running acouple of hours after I was able to get WiFi running inside the game(I had researched how to send and receive messages using ESP-NOW priorto that).  The hard part was freeing enough memory to get the WiFisystem to start in the first place.  If you look closely at themonitors in the photos, you can see that the image’s borders are cutat the sides: the drawing area is only 240x240 pixels (as opposed tothe usual 320x240).  The monitor still thinks it’s using the oldresolution, in effect what I did was increase the horizontal front-and back-porch of the VGA timing, which decreases the horizontalresolution but keeps everything else unchanged (crucially, the hsynctiming).</p><p>That took care of the RAM, but we also had a ROM problem: with theadded WiFi library, the program binary itself ended up too big to fitthe flash (at least with the default Arduino IDE settings). So Iremoved some sprites, an entire tileset (<code>castle</code>) and cut some tilesfrom another tileset (<code>castle3</code>).  To do that I made the <code>conv_spr</code>tool (in the <code>conv_img</code> directory in the Github repository) – it’s animprovement of the tool I had made before but hadn’t released.</p><p>The nice side of all that work is that now it’s much easier to changethe resolution with the new VGA code.  It can also select betweenusing double framebuffers (as before) or a single framebuffer.  I madethat when researching ways to decrease VGA memory use – it turns outthat the game <em>almost</em> runs well enough with a single framebuffer, butit’s not quite fast enough to draw the whole screen during<a href="https://en.wikipedia.org/wiki/Vertical_blanking_interval">vblank</a>(the time when the monitor is not actively drawing the image), so thetop portion of the screen gets a little messed up if we try.  That’swhy the solution I chose at the end was to decrease the resolution andkeep using two framebuffers, but I kept the code to use a singleframebuffer in case I need it for another project in the future.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;More progress in porting Loser Corps to the ESP32 (&lt;a href=&quot;/2021/02/28/Porting-Loser-Corps-to-the-ESP32/&quot; title=&quot;here&amp;#39;s part 1&quot;&gt;here</summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
    <category term="loser-corps" scheme="http://moefh.github.io/tags/loser-corps/"/>
    
    <category term="network" scheme="http://moefh.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Homemade ESP32 VGA Boards</title>
    <link href="http://moefh.github.io/2021/04/02/Homemade-ESP32-VGA-Boards/"/>
    <id>http://moefh.github.io/2021/04/02/Homemade-ESP32-VGA-Boards/</id>
    <published>2021-04-02T03:33:36.000Z</published>
    <updated>2021-04-02T03:32:28.265Z</updated>
    
    <content type="html"><![CDATA[<p>To start experimenting with the networking code of the <a href="/2021/03/07/Porting-Loser-Corps-to-the-ESP32-Part-2/" title="ESP32 game engine">ESP32 game engine</a>, I madea new board for the ESP32 so I can have two of them running the gameand talking to each other.  The new board was supposed to be just acopy of the original one, but I discovered a silly mistake I made inthe original wiring: the red-high and red-low wires were reversed.This caused quite a mess in the colors, I’m surprised I didn’t noticeit before:</p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/cmp-1.jpg" alt="Comparison showing that the old board has wrong red levels"></p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/cmp-2.jpg" alt="Zoom in the &quot;P&quot;"></p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/cmp-3.jpg" alt="Bridge and torch"></p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/cmp-4.jpg" alt="Zoom in the torch"></p><p>The “new dac” label refers to the fixed DACs I wrote about in the <a href="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/" title="last post">last post</a>. I’mnot sure I can see any difference between the old an new DACs, to behonest (my phone camera doesn’t help – its automatic color balancemesses up the colors way more than my DACs, apparently).</p><p>In any case, it’s easy to see the difference between the old and newboards. Not only the new board’s images have a blue-greenish tintoverall (less red), we can also see that the red gradient in the “P”is clearly fixed – what should be <code>black</code>-&gt;<code>dark red</code>-&gt;<code>medium red</code>-&gt;<code>bright red</code> was wrongly shown as <code>black</code>-&gt;<code>medium red</code>-&gt;<code>dark red</code>-&gt;<code>bright red</code>, which is happens when the low and high bits of thered component are swapped:</p><table><thead><tr><th></th><th>correct gradient</th><th>swapped first and second bits</th></tr></thead><tbody><tr><td>binary</td><td>00 01 10 11</td><td>00 10 01 11</td></tr><tr><td>decimal</td><td>0  1  2  3</td><td>0  2  1  3</td></tr></tbody></table><p>Of course, since we can select the ESP32 output pins any way we want,it’s easy to fix this in software by simply changing the pinassignments in the <code>pin_config</code> array in <code>vga_game.ino</code>: just swap<code>PIN_RED_LOW</code> and <code>PIN_RED_HIGH</code>. That’s good news for me because Idon’t feel like making a third board right now.</p><p>And finally, just for reference, here are all of the homemade boardsI’m using in this project:</p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/new_board.jpg" alt="New board"></p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/old_board.jpg" alt="Old board (notice that the red wires don&#39;t cross, unlike the blue and green ones)"></p><p><img src="/2021/04/02/Homemade-ESP32-VGA-Boards/dacs.jpg" alt="DACs"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;To start experimenting with the networking code of the &lt;a href=&quot;/2021/03/07/Porting-Loser-Corps-to-the-ESP32-Part-2/&quot; title=&quot;ESP32 game e</summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
    <category term="perfboard" scheme="http://moefh.github.io/tags/perfboard/"/>
    
  </entry>
  
  <entry>
    <title>Porting Loser Corps to the ESP32 - Part 3</title>
    <link href="http://moefh.github.io/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/"/>
    <id>http://moefh.github.io/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/</id>
    <published>2021-03-27T19:11:51.000Z</published>
    <updated>2021-04-01T23:37:30.115Z</updated>
    
    <content type="html"><![CDATA[<p>More progress in porting Loser Corps to the ESP32 (<a href="/2021/02/28/Porting-Loser-Corps-to-the-ESP32/" title="here&#39;s part 1">here&#39;s part 1</a> of the saga).</p><p>Even though there’s nothing <em>really</em> exciting to report, this is avery long post because there’s a lot of small changes:</p><ul><li>Wiimote support</li><li>New VGA DACs</li><li>Rewriting the VGA output code</li><li>New font</li></ul><h2 id="Wiimote-Support"><a href="#Wiimote-Support" class="headerlink" title="Wiimote Support"></a>Wiimote Support</h2><p>The game now supports the Wiimote controller (via Bluetooth) usingtakeru’s <a href="https://github.com/takeru/Wiimote">Wiimote</a> library. I hadto make a very small change to use it: I added a <code>void *</code> parameter tothe callback function, so it can update the state of the controllerobject without forcing it to refer to the global binding.</p><p>The library works perfectly, the only slightly annoying thing is thatI haven’t figured out how to permanently pair the controller with theESP32, so every time the ESP32 restarts you have to press the Wiimotebuttons 1 and 2 at the same time to make the Bluetooth connection. Nota big deal, but it could be better.</p><h2 id="New-VGA-DACs"><a href="#New-VGA-DACs" class="headerlink" title="New VGA DACs"></a>New VGA DACs</h2><p>I made a new VGA connector with new digital-to-analog converters(DACs). The old ones are slightly wonky because I didn’t haveresistors with good values when I made it, so I finally got some newresistors and made a new one:</p><p><img src="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/new-dac.jpg" alt="New VGA connector with DACs"></p><p>For comparison, here’s the old one:</p><p><img src="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/old-dac.jpg" alt="Old VGA connector with DACs"></p><p>To see why the new DACs are better than the old ones, we have to talkabout how the VGA color signal is generated.  The monitor wants toreceive each color component (Red, Green, Blue) in their own wire,with a voltage between 0V and 0.7V indicating its intensity.  Toproduce an image, the voltage has to be changed as the monitor sweepsthe screen to draw the pixels: each pixel is drawn with the RGBintensity corresponding to the voltage of the red, green and bluewires at the time it’s being drawn.</p><p>The ESP32 only has 2 internal DAC outputs, so we can’t use them tocreate the 3 voltages we need for the RGB wires (even if it had 3, itsDACs aren’t fast enough to generate the signal we need at over12MHz).  So we make the ESP32 output each color component as multipledigital pins: in our case, we use 2 pins per component. Since adigital pin has two logical values (0 and 1), each component has 4possible combinations (00, 01, 10, 11), and the DAC has to convertthese to 4 voltages between 0V and 0.7V. Ideally, we’d like to mapthem like this:</p><table><thead><tr><th>pin values (from ESP32)</th><th>intensity</th><th>output voltage (to VGA monitor)</th></tr></thead><tbody><tr><td>00</td><td>0%</td><td>0V</td></tr><tr><td>01</td><td>33%</td><td>0.23V</td></tr><tr><td>10</td><td>67%</td><td>0.47V</td></tr><tr><td>11</td><td>100%</td><td>0.7V</td></tr></tbody></table><p>The ESP32 output pins give 3.3V when high (logical 1) and 0V when low(logical 0), so we can build a small circuit connecting them toresistors to generate the desired output voltages:</p><p><img src="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/dac-schematic.png" alt="DAC schematic (for each color component)"></p><p>That’s the DAC. We just have to choose values for R1 and R2 so thatwhen Pin1 and Pin2 are high/low we have the desired voltage in outputas shown in the table above. (By the way, the 75Ω resistor is therefor impedance matching with the monitor – I don’t think it’s reallyright, but I don’t know how to match the impedance properly).</p><p>The old DAC had resistor values of 1KΩ and 560Ω, which is what I hadavailable at the time. The new DAC has 1KΩ and 470Ω, which outputsvoltages closer to what we want:</p><p><img src="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/dac-graph.png" alt="DAC output voltages (dotted lines show theoretical best)"></p><p>The dotted lines show the theoretical best values for each pin valueexcept for <code>00</code>, which has the trivial-to-generate voltage level of0V.  The new DAC is overall closer to the theoretical best, but mostimportantly, it has more consistent spacing between the levels, whilethe old DAC has the interval between 01 and 10 smaller then the otherones.</p><p>I’m not sure the image result is that different, but for the recordhere’s a photo of the game running with the new DACs:</p><p><img src="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/screen.jpg" alt="Game screen with the new DACs"></p><h2 id="Rewriting-the-VGA-Output-Code"><a href="#Rewriting-the-VGA-Output-Code" class="headerlink" title="Rewriting the VGA Output Code"></a>Rewriting the VGA Output Code</h2><p>I ended up rewriting the VGA output code. I was using bitluni’sexcellent <a href="https://github.com/bitluni/ESP32Lib">ESP32Lib</a>, but thatlibrary does a lot of stuff we don’t need. That makes the code largerand also more complicated: when reading the code, I had troublefollowing exactly how things are done with the code written in C++with multiple inheritance.</p><p>So to make sure I understood every detail, I ended up rewriting thecode in plain C style. My code supports only double-buffered output,and changing the resolution requires altering the appropriateconstants by hand (I might make it easier to change it if I end upusing this code for something else).  It also doesn’t have any drawingAPI, all drawing must be done by writing directly to the framebuffer– which suits the game just fine, because I was already doing thatwith ESP32Lib.</p><p>My only improvement over ESP32Lib was making the I2S system trigger aninterrupt at the end of each frame (the interrupy simply increments aframe counter). With that, the main game loop can now wait for the endof the frame to swap the framebuffers and start drawing again(basically a vsync). That removes the annoying horizontal line fromthe screen which happens when the image is updated while it’s beingdrawn, and also forces a constant framerate (that’s why that photoabove shows 60fps).</p><p>It’s still possible to disable the vsync (returning to the oldvariable framerate and annoying horizontal line), which I dooccasionally to check the performance of the game.</p><h2 id="New-Font"><a href="#New-Font" class="headerlink" title="New Font"></a>New Font</h2><p>Since I’m not using ESP32Lib anymore, I had to make my own font andfont-rendering code (which is pretty unoptimized, but for now itdoesn’t matter since I’m only using text for debugging).  I used<a href="https://krita.org/en/">Krita</a> to draw the font because it’s easier todraw pixel-by-pixel with it than with Gimp.</p><p>Here’s an image of the 6x8 font:</p><p><img src="/2021/03/27/Porting-Loser-Corps-to-the-ESP32-Part-3/font.png" alt="The new font"></p><p>(The yellow/greenish background is what I used when drawing the font.)</p><h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>I’m not sure what I’ll do next: probably either sound or network. Fornetwork, I haven’t even decided if I’ll use ESP32’s “ESP-NOW” protocolor normal WiFi/IP, but it will be fun to investigate the pros and consof each one.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;More progress in porting Loser Corps to the ESP32 (&lt;a href=&quot;/2021/02/28/Porting-Loser-Corps-to-the-ESP32/&quot; title=&quot;here&amp;#39;s part 1&quot;&gt;here</summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
    <category term="loser-corps" scheme="http://moefh.github.io/tags/loser-corps/"/>
    
    <category term="wiimote" scheme="http://moefh.github.io/tags/wiimote/"/>
    
  </entry>
  
  <entry>
    <title>Porting Loser Corps to the ESP32 - Part 2</title>
    <link href="http://moefh.github.io/2021/03/07/Porting-Loser-Corps-to-the-ESP32-Part-2/"/>
    <id>http://moefh.github.io/2021/03/07/Porting-Loser-Corps-to-the-ESP32-Part-2/</id>
    <published>2021-03-07T20:02:26.000Z</published>
    <updated>2021-04-04T04:12:18.998Z</updated>
    
    <content type="html"><![CDATA[<p>I made some progress in porting Loser Corps to the ESP32 (<a href="/2021/02/28/Porting-Loser-Corps-to-the-ESP32/" title="here&#39;s part 1">here&#39;s part 1</a> of the saga).</p><p>Here’s a demo video (click to open Youtube):</p><p><a href="https://www.youtube.com/watch?v=BvJ3HLKo6p4"><img src="/2021/03/07/Porting-Loser-Corps-to-the-ESP32-Part-2/loser1.jpg" alt="Youtube video"></a></p><p>(This video shows a slightly older version where collision detectionwas done with the image rectangle, not the character’s clippingrectangle, which is why it looks a little wonky in a few places.)</p><p>As the video shows, you control a character in a map, walking andjumping around.  I reworked some parts of the movement code, but itfeels a lot like the original, although I think the jump is not highenough.  The collision detection is pretty much untouched, except forwhat I absolutely had to do to make it run in the ESP32, which wasn’tmuch.</p><p>The joystick I’m using is a common Arduino joystick shield.  It’spretty cheap and easy to use, but it requires one input pin of theESP32 for each button, and one analog input pin for each direction ofthe stick – it’s really just a bunch of of buttons and<a href="https://en.wikipedia.org/wiki/Potentiometer">potentiometers</a>conveniently placed on a PCB:</p><p><img src="/2021/03/07/Porting-Loser-Corps-to-the-ESP32-Part-2/loser3.jpg" alt="The Arduino joystick shield I&#39;m using"></p><p>I’ve connected all buttons pins, but the code only uses the C buttonto jump and the X analog stick to move.</p><p>I’ve tried to use a Wiimote nunchuck and a Wiimote classic controller,but I didn’t have much success.  These controllers use an<a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> interface to talk to theWiimote, so it seems like they should be easy to use with the ESP32 –and it actually works, but it’s very unreliable.  The controller stopsreplying for no apparent reason, a lot of times requiring anunplug/re-plug to start working again.  I’ve tried it with no pullupresistors, 4.7K pullups, 10K pullups, all for nothing.  The strangestthing is that it works perfectly with an Arduino Uno (using the sameexact test code), even with no pullup resistors.  I say people sayingthat the I2C part of the ESP32 Arduino library isn’t that great, somaybe that’s the problem?</p><p>Another nice option would be to use the Wiimote itself, which usesBluetooth.  That’s probably the next thing I’ll work on in thisproject.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I made some progress in porting Loser Corps to the ESP32 (&lt;a href=&quot;/2021/02/28/Porting-Loser-Corps-to-the-ESP32/&quot; title=&quot;here&amp;#39;s part </summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
    <category term="loser-corps" scheme="http://moefh.github.io/tags/loser-corps/"/>
    
    <category term="joystick" scheme="http://moefh.github.io/tags/joystick/"/>
    
  </entry>
  
  <entry>
    <title>Porting Loser Corps to the ESP32</title>
    <link href="http://moefh.github.io/2021/02/28/Porting-Loser-Corps-to-the-ESP32/"/>
    <id>http://moefh.github.io/2021/02/28/Porting-Loser-Corps-to-the-ESP32/</id>
    <published>2021-02-28T18:17:35.000Z</published>
    <updated>2021-04-04T04:09:14.130Z</updated>
    
    <content type="html"><![CDATA[<p>I started porting <a href="https://github.com/moefh/loser-corps">Loser Corps</a>,a video game I and a few friends made in the old days of 1998-1999, tothe <a href="https://en.wikipedia.org/wiki/ESP32">ESP32</a>.</p><p>I’m using bitluni’s <a href="https://github.com/bitluni/ESP32Lib">ESP32Lib</a> togenerate the VGA output, and I’m still using my crappy homemade DACwith 2 bits per color component I showed in the <a href="/2021/02/21/ESP32-VGA-output/" title="last post">last post</a>.  The only new addition is a littleboard I made to connect the pins from the ESP32 devkit to the VGAbreakout board without the mess I had in the breadboard, and animprovised cardboard box to hold the VGA plug in place (it workssurprisingly well).  I’ll probably make a nicer board and box when Iadd joystick input and sound output.</p><p>The code currently renders a static screen with the background filledwith tiles, some sprites and some foreground tiles. It’s probably areasonable test of how fast things will render:</p><p><img src="/2021/02/28/Porting-Loser-Corps-to-the-ESP32/setup.jpg" alt="The whole setup"></p><p>The game images look a little rough when converted to 64 colors,especially since the palette is fixed by the hardware, but I think Ican get used to it:</p><p><img src="/2021/02/28/Porting-Loser-Corps-to-the-ESP32/screenshot.jpg" alt="Screenshot of the game"></p><p>I managed to get a descent render speed after I started writing to thescreen 4 pixels at a time. The annoying thing about this whole thingis that because of the way the ESP32 I2S DMA works, the data in theframebuffer has to be set in a weird order:</p><table><thead><tr><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th><th><!-- --></th></tr></thead><tbody><tr><td>pixels</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>…</td></tr><tr><td>address</td><td>[2]</td><td>[3]</td><td>[0]</td><td>[1]</td><td>[6]</td><td>[7]</td><td>[4]</td><td>[5]</td><td>…</td></tr></tbody></table><p>Another annoying thing is that the VSync and HSync bits for the VGAsignal have to go inside every pixel in the framebuffer. To makethings fast, I pre-baked these bits in the image data, which meansthat if I want to change to a VGA mode that happens to have differentVSync or HSync polarity, I’ll have to re-convert the images andrecompile everything. Not a big deal, but it’s annoying.</p><p>Currently my code only supports placing images aligned horizontally to4 pixels (i.e., the x coordinate must be a multiple of 4). With that,the trick of writing 4 pixels at a time, and <em>not</em> clearing the screenevery frame (since I’m going to overwrite everything anyway), Imanaged to get around 150 frames per second. We’ll have to see how badit gets once I remove the restriction on the horizontal alignment.</p><p>All in all, I’m very pleased with the progress.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I started porting &lt;a href=&quot;https://github.com/moefh/loser-corps&quot;&gt;Loser Corps&lt;/a&gt;,
a video game I and a few friends made in the old days o</summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
    <category term="loser-corps" scheme="http://moefh.github.io/tags/loser-corps/"/>
    
  </entry>
  
  <entry>
    <title>ESP32 VGA output</title>
    <link href="http://moefh.github.io/2021/02/21/ESP32-VGA-output/"/>
    <id>http://moefh.github.io/2021/02/21/ESP32-VGA-output/</id>
    <published>2021-02-21T18:48:01.000Z</published>
    <updated>2021-03-10T01:02:45.303Z</updated>
    
    <content type="html"><![CDATA[<p>Some time ago I made a VGA connector with a simple DAC made ofresistors to use with old FPGA board, but since the board has verylittle RAM I wasn’t able to do anything <a href="https://github.com/moefh/fpga-vga-driver">toointeresting</a> (the DAC shownthere has only 1 bit per color channel, I later made an improved onewith 2 bits per channel).  But as it turns out, some crazy people madethe ESP32 output a VGA signal using I2S – I just tested it and itseems to work perfectly!</p><p>I used <a href="https://github.com/fdivitto/FabGL">FabGL</a> by Fabrizio DiVittorio, but there’s also<a href="https://github.com/bitluni/ESP32Lib">ESP32Lib</a> by bitluni which I’llprobably check out later.  Here’s one of FabGL’s examples in action(pay no attention to the smudges on the monitor, it’s very old):</p><p><img src="/2021/02/21/ESP32-VGA-output/image3.jpg" alt="ESP32 outputting to an old CRT monitor"></p><p>Here’s a close-up of the ESP32 showing the connected pins.</p><p><img src="/2021/02/21/ESP32-VGA-output/image7.jpg" alt="Showing the connected pins"></p><p>I’m using the default FabGL pinout, which is:</p><table><thead><tr><th align="right">ESP32 pin</th><th>Connection</th></tr></thead><tbody><tr><td align="right">23</td><td>H Sync</td></tr><tr><td align="right">15</td><td>V Sync</td></tr><tr><td align="right">22</td><td>Red (high bit)</td></tr><tr><td align="right">21</td><td>Red (low bit)</td></tr><tr><td align="right">19</td><td>Green (high bit)</td></tr><tr><td align="right">18</td><td>Green (low bit)</td></tr><tr><td align="right">5</td><td>Blue (high bit)</td></tr><tr><td align="right">4</td><td>Blue (low bit)</td></tr></tbody></table><p>And finally, here’s my hacky VGA connector/DAC with 2 bits per colorchannel giving a total of 64 colors:</p><p><img src="/2021/02/21/ESP32-VGA-output/image6.jpg" alt="My homemade VGA connector/DAC"></p><p>The other side of the board is kind of a mess (this was one of myfirst soldering jobs), but it works well enough.  And, before you ask,all of the jumpers are inserted all the way in, but some have longerleads than others – they’re really crappy jumpers!</p><p>I might try to port <a href="https://github.com/moefh/loser-corps">LoserCorps</a> to this thing. No ideahow well it will work over Wifi, the network code is <em>very</em> simplisticand probably doesn’t work well anywhere other than Ethernet. We’llsee.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Some time ago I made a VGA connector with a simple DAC made of
resistors to use with old FPGA board, but since the board has very
little </summary>
      
    
    
    
    
    <category term="esp32" scheme="http://moefh.github.io/tags/esp32/"/>
    
    <category term="vga" scheme="http://moefh.github.io/tags/vga/"/>
    
  </entry>
  
  <entry>
    <title>STM32 with pure assembly</title>
    <link href="http://moefh.github.io/2021/02/15/STM32-with-pure-assembly/"/>
    <id>http://moefh.github.io/2021/02/15/STM32-with-pure-assembly/</id>
    <published>2021-02-15T22:14:52.000Z</published>
    <updated>2021-04-02T00:02:11.902Z</updated>
    
    <content type="html"><![CDATA[<p>I was finally able to get my hands on an STM32!  This board (sometimescalled “Blue Pill”) is pretty cheap and has a STM32F103C8T6 chip onit:</p><p><img src="/2021/02/15/STM32-with-pure-assembly/image1.jpg" alt="ST-Link programmer connected to the Blue Pill"></p><p>The STM32F103C8T6 chip has an ARM Cortex-M3 core, 20KB of SRAM and64KB of flash.  I have great memories of playing with ARM processorswith the Game Boy Advance (ARM7TDMI) and Nintendo DS (ARM946E-S), so Idecided to try to write some stuff using just assembly.</p><p>The whole deal was much easier than I expected. In the Nintendo DSdays I had to compile my own gcc and binutils to be able to buildbinaries, and then use a “backup” flash cartridge to run them in thehardware. Today things are much easier: the “ST-Link” programmer isvery cheap (although what I got is probably a clone), the Arduino IDEsupports STM32 with a simple change in its configuration, and peoplemake Linux packages for the cross-compiler and other tools (there’salso the STM32CubeIDE, which is based on Eclipse and is provided byST). For my needs, I just had to install <code>binutils-arm-none-eabi</code> and<code>gcc-arm-none-eabi</code> on Ubuntu and I was well on my way to write somecode.</p><p>Now, since I wanted to write pure assembly with no help from anycompiler or library, I needed a linker script, which tells the linkerwhere each section of the program goes in memory. I searched the webbut couldn’t find anyone who had <em>exactly</em> what I needed: exampleswere either for the right chip but other toolchains (there’s anYouTube video of someone doing this with the STM32CubeMX IDE, whichdoesn’t seem to use GNU’s ld?), or they were using the GNU toolchainbut for different STM32 chips. So I ended up mixing and matching (andconfirming things in the STM32F10x user manual) and ended up withthis:</p><figure class="highlight plain"><figcaption><span>stm32f103.ld</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* linker script for stm32f103.ld *&#x2F;</span><br><span class="line"></span><br><span class="line">ENTRY(start);</span><br><span class="line"></span><br><span class="line">MEMORY &#123;</span><br><span class="line"> RAM   (rwx) : ORIGIN &#x3D; 0x20000000, LENGTH &#x3D; 20K</span><br><span class="line"> FLASH (rx)  : ORIGIN &#x3D; 0x08000000, LENGTH &#x3D; 64K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    *(.isr_vector)  &#x2F;* &lt;-- this has to be at the very start of flash *&#x2F;</span><br><span class="line">    *(.text)</span><br><span class="line">    *(.text*)</span><br><span class="line">    *(.rodata)</span><br><span class="line">    *(.rodata*)</span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">  &#125; &gt; FLASH</span><br><span class="line"></span><br><span class="line">  __data_flash &#x3D; .;</span><br><span class="line"></span><br><span class="line">  .data : AT ( __data_flash )</span><br><span class="line">  &#123;</span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    __data_start &#x3D; .;</span><br><span class="line">    *(.data)</span><br><span class="line">    *(.data*)</span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    __data_end &#x3D; .;</span><br><span class="line">  &#125; &gt; RAM</span><br><span class="line"></span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">    __bss_start &#x3D; .;</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss*)</span><br><span class="line">    *(COMMON)</span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    __bss_end &#x3D; .;</span><br><span class="line">  &#125; &gt; RAM</span><br><span class="line"></span><br><span class="line">  __stack_size &#x3D; 1024;</span><br><span class="line">  __stack_end &#x3D; ORIGIN(RAM)+LENGTH(RAM);</span><br><span class="line">  __stack_start &#x3D; __stack_end - __stack_size;</span><br><span class="line">  . &#x3D; __stack_start;</span><br><span class="line">  .stack :</span><br><span class="line">  &#123;</span><br><span class="line">    . &#x3D; . + __stack_size;</span><br><span class="line">  &#125; &gt; RAM</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It has a lot of stuff I don’t need (a lot of these sections are usedby gcc), but I kept them anyway since they don’t hurt and I might wantto use them in the future.</p><p>The assembly code needed to set up and control a GPIO pin is prettysimple, the only thing that stumped me for a bit was not knowing thatthe flash memory needs to have an interrupt vector at the very start.I ended up putting it in its own section, <code>.isr_vector</code>, to make easyfor the linker script to place it exactly at the flash beginning.  Thefirst entry of the vector is not an interrupt handler, but the addressof the top of the stack region (the stack grows down), and the secondone is the address of the start of the code.  Apparently it reallywants some extra entries there for other handlers; the CPU locks up ifthey’re not present (even though I made the handlers themselves intoan infinite loop). I’m not entirely sure what’s going on there, butadding 6 handlers after the start address seems to keep the CPU happy.</p><p>Anyway, here’s the assembly code. In the STM32, everything iscontrolled via registers mapped in memory. The code first enables theclock for the pins on port C (all peripheral clocks start disabled tosave power), then configures pin 13 of port C as output, then sets thepin state, and then loops forever.</p><figure class="highlight armasm"><figcaption><span>main.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">        .cpu cortex-m3</span><br><span class="line">        .syntax unified</span><br><span class="line">        <span class="meta">.thumb</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="comment">@ isr_vector</span></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="meta">.section</span> .isr_vector</span><br><span class="line">        <span class="meta">.word</span> __stack_end</span><br><span class="line">        <span class="meta">.word</span> start</span><br><span class="line">        <span class="meta">.word</span> halt      <span class="comment">@ NMI handler</span></span><br><span class="line">        <span class="meta">.word</span> halt      <span class="comment">@ hard fault</span></span><br><span class="line">        <span class="meta">.word</span> halt      <span class="comment">@ memory fault</span></span><br><span class="line">        <span class="meta">.word</span> halt      <span class="comment">@ bus fault</span></span><br><span class="line">        <span class="meta">.word</span> halt      <span class="comment">@ usage fault</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">.text</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="comment">@ start</span></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="meta">.global</span> start</span><br><span class="line">        <span class="meta">.thumb_func</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">@ enable clock for port C pins</span></span><br><span class="line">        <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="number">=0x10</span>             <span class="comment">@ bit 4 = port C enable</span></span><br><span class="line">        <span class="keyword">ldr</span> <span class="built_in">r1</span>, <span class="number">=0x40021000</span>       <span class="comment">@ RCC base address</span></span><br><span class="line">        <span class="keyword">str</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="number">#0x18</span>]       <span class="comment">@ 0x18 = reg for APB2 enable (where port C lives)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">@ configure port C pin 13 as output</span></span><br><span class="line">        <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="number">=0x44244444</span>       <span class="comment">@ set pin 13 as output, other 7 pins stay as input</span></span><br><span class="line">        <span class="keyword">ldr</span> <span class="built_in">r1</span>, <span class="number">=0x40011000</span>       <span class="comment">@ port C base address</span></span><br><span class="line">        <span class="keyword">str</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="number">#0x04</span>]       <span class="comment">@ 0x04 = reg for config of 8 higher pins of port</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">@ set port C pin 13 to high (commented) or low</span></span><br><span class="line">        <span class="comment">@ldr r0, =0x2000          @ pin 13 high (0x2000 = 1&lt;&lt;13)</span></span><br><span class="line">        <span class="keyword">ldr</span> <span class="built_in">r0</span>, <span class="number">=0</span>                <span class="comment">@ pin 13 low</span></span><br><span class="line">        <span class="keyword">str</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="number">#0x0c</span>]       <span class="comment">@ 0x0c = reg for output data of port pins</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start_loop:</span></span><br><span class="line">        <span class="keyword">b</span> start_loop</span><br><span class="line"></span><br><span class="line"><span class="symbol">start_end:</span></span><br><span class="line">        .pool</span><br><span class="line"></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="comment">@ halt</span></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="meta">.thumb_func</span></span><br><span class="line"><span class="symbol">halt:</span></span><br><span class="line">        <span class="keyword">b</span> halt</span><br><span class="line"></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="comment">@ DATA section</span></span><br><span class="line">        <span class="comment">@ (not used, added here just to check that</span></span><br><span class="line">        <span class="comment">@ the linker script is working)</span></span><br><span class="line">        <span class="comment">@ ======================================</span></span><br><span class="line">        <span class="meta">.section</span> <span class="meta">.data</span></span><br><span class="line">        <span class="meta">.ascii</span> <span class="string">&quot;Hello, world!\0&quot;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>The board has an LED connected to pin 13 of port C; it seems that theLED’s cathode is connected to the pin (with the anode connected to+Vdd) because the LED turns on when the pin is brought low.</p><p>This code works, but if I ever want to use the stuff in the <code>.data</code>section, I’ll have to copy it from the flash memory to RAM.  Thelinker script is prepared for that: it defines the symbol<code>__data_flash</code> to the address of the very end of the <code>.text</code> section,which is the start of where the <code>.data</code> section stuff is located inthe flash memory.  So I’ll just have to make a <code>memcpy</code> function thatcopies <code>__data_end-__data_start</code> bytes from <code>__data_flash</code> to<code>__data_start</code> (which is the address of the <code>.data</code> section in RAM).</p><p>After assembling the code with <code>arm-none-eabi-as</code> and linking it with<code>arm-none-eabi-ld</code>, I used <code>arm-none-eabi-objcopy</code> to convert the ELFexecutable to a stripped out binary suitable to write to flash. Theseare the commands that <code>make</code> runs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-as -o main.o main.s</span><br><span class="line">arm-none-eabi-ld -Tstm32f103.ld -o main.elf main.o</span><br><span class="line">arm-none-eabi-objcopy -O binary main.elf main.bin</span><br></pre></td></tr></table></figure><p>And, finally, to upload the final binary to the flash in the chip Iended up using the Windows STLink command line utility that theArduino IDE installs when you install the STM32 boards. I think it’sthe same tool that can be downloaded from the STM32 website (whichcomes with a GUI besides the command line tool), but I haven’tchecked.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I was finally able to get my hands on an STM32!  This board (sometimes
called “Blue Pill”) is pretty cheap and has a STM32F103C8T6 chip o</summary>
      
    
    
    
    
    <category term="stm32" scheme="http://moefh.github.io/tags/stm32/"/>
    
    <category term="arm" scheme="http://moefh.github.io/tags/arm/"/>
    
    <category term="assembly" scheme="http://moefh.github.io/tags/assembly/"/>
    
  </entry>
  
</feed>
